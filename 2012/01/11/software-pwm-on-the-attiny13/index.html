<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1"><title>Software PWM on the ATtiny13 - travisgeis.com</title><link rel="icon" href="/img/favicon.png"><link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-alpha.6/css/bootstrap.min.css" integrity="sha384-rwoIResjU2yc3z8GV/NPeZWAv56rSmLldC3R/AZzGRnGxQQKnKkoFVhFQhNUwEyJ" crossorigin="anonymous"><link href="https://fonts.googleapis.com/css?family=Lato|Permanent+Marker" rel="stylesheet"><link rel="stylesheet" href="/vendor/font-awesome-4.7.0/css/font-awesome.min.css"><link rel="stylesheet" href="/css/boxy.css"></head><body><nav id="menu" class="nav nav-pills flex-column flex-sm-row"><a href="/" class="flex-sm-fill text-sm-center nav-link"><i aria-hidden="true" class="fa inline-icon fa-home"></i>travisgeis.com</a><a href="/contact" class="flex-sm-fill text-sm-center nav-link"><i aria-hidden="true" class="fa inline-icon fa-comments"></i>Contact</a><a href="/archives" class="flex-sm-fill text-sm-center nav-link"><i aria-hidden="true" class="fa inline-icon fa-archive"></i>Archives</a></nav><div id="page" class="container"><div id="titles-container"><div id="titles"><h1>Software PWM on the ATtiny13</h1><h3 class="date">11 January, 2012</h3></div></div><div id="content"><article id="post"><img src="/uploads/2012/01/body-IMG_2929-e1326866475822.jpg" alt="A first go at the Stardweeny using an ATtiny13">
<p>This year for the holidays I created a little dynamic ornament with five
channels of independent LED light. The prototype, which had to be finished in a
matter of days, used an Ardweeny board from Solarbotics. The Ardweeny is based
on the ATmega328, a great chip with more than five hardware channels for PWM
(pulse-width modulation). While I love the ATmega chips, they get a bit pricey
at $5 apiece just to drive some LEDs.</p>
<p>I was shopping on Digi-Key for alternatives and decided to try a couple of
ATtiny13 microcontrollers. The ATtiny13 is a small, low-power AVR with the
standard 8-bit core size, and conveniently comes with a 9.6-MHz internal RC
oscillator. Because the ATtiny has an internal oscillator, I knew I could keep
my hardware very minimal and thus very small, a requirement for the small paper
ornament I was hoping to build.</p>
<p>The problem is that the ATtiny13 has only one PWM output. If I used only its
hardware functionality, I would get one channel of control, where I needed five.
To solution is to implement a simple software PWM. In this post I describe my
process of getting software PWM (and embedded C programming in general) working
on the ATtiny13.</p>
<a id="more"></a>
<p>The first step with programming any part is reading the datasheet [link]. The
Attiny13 comes with 1KB of internal flash memory for programs. When I ordered it
this sounded plenty large for my purposes, but I forgot to account for the heavy
Arduino libraries I’m used to using, whose needed functionality I would have to
implement myself in the code. 1KB turns out to feel like a tiny amount of space.</p>
<p>1KB is too small to hold the floating-point math libraries of AVR-LibC, the C
library I use for AVR programs. It’s also too small to hold the math.h library,
which includes the trigonometry functions. In my ‘328-based prototype I used a
sin() function to calculate the brightness levels of the light channels, to give
a soothing light pulsation. That won’t be an option on the tiny13.</p>
<p>I had a lot of trouble getting started with C on the ATtiny. It’s not too
complicated once you get going, though.</p>
<h2 id="Implementing-Software-PWM"><a href="#Implementing-Software-PWM" class="headerlink" title="Implementing Software PWM"></a>Implementing Software PWM</h2><p>Software PWM uses an inbuilt functionality of the microcontroller called a
timer. The timer counts off clock cycles, and when it reaches a certain point,
in this case its maximum value of 255 (the max value of a single unsigned byte),
the timer triggers an interrupt.</p>
<p>The interrupt is important precisely because it interrupts the running code.
Specifically, it tells the microcontroller to jump to a predefined location in
program memory, execute the instructions there, and then return to the main
routine. For software-based PWM, the timer interrupt is perfect. It frees up the
main program logic by periodically and consistently executing the same function,
called an Interrupt Service Routine.</p>
<p>So the desired program flow looks like this:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">main()&#123;</div><div class="line">	loop infinitely, changing the output levels</div><div class="line">	accordingly.</div><div class="line">&#125;</div><div class="line"></div><div class="line">ISR()&#123;</div><div class="line">	run now and then, twiddling the hardware</div><div class="line">	outputs to correspond with the output levels</div><div class="line">	<span class="built_in">set</span> in main</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>The main function in my case was supposed to set the output level of each of
five LEDs such that one LED would “lead” the others in a gentle up-down
pulsation. The ISR would be responsible for dealing with the actual on-off
settings of the LEDs.</p>
<p>For my project I chose a PWM resolution of one byte, or eight bits. A byte
allows for 256 possible output levels, plenty more than the eye can see in
brightness gradation. A resolution of 256 means that there are 256 “time slots”
wherein an LED can turn on or off.</p>
<p>For example, if the brightness of the LED is supposed to be 255, it is on from
time slot “0” all the way to time slot “255”—in other words, all the time. If
the brightness is 0, the LED is off for every cycle. If the brightness is 100,
the LED is on for the first hundred cycles, then off for the remaining 155.</p>
<p>The resulting output is not smooth, but a series of full-on and full-off
positions that, to the relatively slow human eye, average together to some
intermediate brightness. So, now we know roughly what the ISR should do:</p>
<ol>
<li>Read the desired brightness level of an LED, in the form of a global variable.</li>
<li>Read the current progress through the 256 cycles</li>
<li><p>Compare the brightness level to the current progress</p>
</li>
<li><p>If the progress is lower than the desired on-time, turn the LED on.</p>
</li>
<li>If the progress is past the desired on-time, turn the LED off.4.  Increment
the progress by one. AVR-LibC says that the ISR for the timer interrupt on the
tiny13 has the signature</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ISR(TIM0_OVF_vect)&#123;&#125;</div></pre></td></tr></table></figure>
<p>The TIM0_OVF_vect parameter indicates that this ISR (potentially one of several)
is specifically for interrupts triggered by a TIMER0 overflow.</p>
<p>Given the pin number of each LED channel, and the brightness level desired, the
ISR body looks like:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">ISR(TIM0_OVF_vect)</div><div class="line">&#123;</div><div class="line">	<span class="keyword">if</span>(ISRcounter &lt; ch1) PORTB |= (<span class="number">1</span> &lt;&lt; CH1_PIN); <span class="comment">//Write the ch1 pin high</span></div><div class="line">	<span class="keyword">else</span> PORTB &amp;= ~(<span class="number">1</span> &lt;&lt; CH1_PIN); <span class="comment">//Write the ch1 pin low</span></div><div class="line"></div><div class="line">	<span class="keyword">if</span>(ISRcounter &lt; ch2) PORTB |= (<span class="number">1</span> &lt;&lt; CH2_PIN);</div><div class="line">	<span class="keyword">else</span> PORTB &amp;= ~(<span class="number">1</span> &lt;&lt; CH2_PIN);</div><div class="line"></div><div class="line">	<span class="keyword">if</span>(ISRcounter &lt; ch3) PORTB |= (<span class="number">1</span> &lt;&lt; CH3_PIN);</div><div class="line">	<span class="keyword">else</span> PORTB &amp;= ~(<span class="number">1</span> &lt;&lt; CH3_PIN);</div><div class="line"></div><div class="line">	<span class="keyword">if</span>(ISRcounter &lt; ch4) PORTB |= (<span class="number">1</span> &lt;&lt; CH4_PIN);</div><div class="line">	<span class="keyword">else</span> PORTB &amp;= ~(<span class="number">1</span> &lt;&lt; CH4_PIN);</div><div class="line"></div><div class="line">	<span class="keyword">if</span>(ISRcounter &lt; ch5) PORTB |= (<span class="number">1</span> &lt;&lt; CH5_PIN);</div><div class="line">	<span class="keyword">else</span> PORTB &amp;= ~(<span class="number">1</span> &lt;&lt; CH5_PIN);</div><div class="line"></div><div class="line">	ISRcounter++;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>where <code>ch1, ch2, ..., ch5</code> are the single-byte output levels of each channel, and
<code>CH1_PIN, CH2_PIN, ..., CH5_PIN</code> are the pin numbers for each channel.</p>
<p>The ISR is actually very simple:</p>
<p>ISRcounter holds the current count of ISR runs (0 to 255). For each channel, if
the ISRcounter is less than the brightness level desired for that channel, write
the LED HIGH (<code>PORTB |= (1 &lt;&lt; pinNumber)</code>). Once the counter exceeds the desired
brightness level, keep writing the LED LOW (<code>PORTB &amp;= ~(1 &lt;&lt; pinNumber)</code>). So,
in effect, the brightness level byte is simply the ON-time of the LED, out of
255.</p>
<p>The rest of the code can now fall into place:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> F_CPU 9.6E6L <span class="comment">/* CPU Freq. Must come before delay.h include. 9.6MHz */</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span>  <span class="comment">/* For data types */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span>  <span class="comment">/* Register and port definitions */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span>  <span class="comment">/* Busy-wait delay functions */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span>  <span class="comment">/* Exposes timers, counters and ISR functions */</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> CH1_PIN PB0 <span class="comment">/* Bind output channels to specific PortB pins. This depends on schematic. */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> CH2_PIN PB1</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> CH3_PIN PB2</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> CH4_PIN PB3</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> CH5_PIN PB4</span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> TIME_OFFSET 50</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> DELAY_MS 3</span></div><div class="line"></div><div class="line"><span class="keyword">uint8_t</span> ch1, ch2, ch3, ch4, ch5; <span class="comment">/* The one-byte PWM level of each channel */</span></div><div class="line"><span class="keyword">uint8_t</span> directions = <span class="number">0xFF</span>;</div><div class="line"><span class="comment">/*</span></div><div class="line">This one-byte flag holds five channel direction bit flags</div><div class="line">0x [nothing] [nothing] [nothing] [ch5] [ch4] [ch3] [ch2] [ch1]</div><div class="line">*/</div><div class="line"></div><div class="line"><span class="keyword">volatile</span> <span class="keyword">uint8_t</span> ISRcounter = <span class="number">0</span>; <span class="comment">/* Count the number of times the ISR has run */</span></div><div class="line"><span class="keyword">uint8_t</span> timeCount;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="comment">/* Setup */</span></div><div class="line">	ch1 = <span class="number">0</span>;</div><div class="line">	ch2 = TIME_OFFSET;</div><div class="line">	ch3 = <span class="number">2</span> * TIME_OFFSET;</div><div class="line">	ch4 = <span class="number">3</span> * TIME_OFFSET;</div><div class="line">	ch5 = <span class="number">4</span> * TIME_OFFSET;</div><div class="line"></div><div class="line">	DDRB = <span class="number">0xFF</span>; <span class="comment">//Every PORTB pin is output</span></div><div class="line">	PORTB = <span class="number">0x00</span>; <span class="comment">//Start with every pin low</span></div><div class="line"></div><div class="line">	TCCR0B |= (<span class="number">1</span> &lt;&lt; CS00); <span class="comment">// disable timer prescale (=clock rate)</span></div><div class="line">	TIMSK0 |= (<span class="number">1</span> &lt;&lt; TOIE0); <span class="comment">// enable timer overflow interrupt specifically 	sei(); // enable interrupts in general 	/* Loop */ 	while(1)&#123; 		if(directions &amp; 1) ch1++; 		else ch1--; 		if(directions &amp; 0B00000010) ch2++; 		else ch2--; 		if(directions &amp; 0B00000100) ch3++; 		else ch3--; 		if(directions &amp; 0B00001000) ch4++; 		else ch4--; 		if(directions &amp; 0B00010000) ch5++; 		else ch5--; 		if(ch1 &gt; 254) directions &amp;= ~0B00000001;</span></div><div class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(ch1 &lt; <span class="number">1</span>) directions |= <span class="number">0B</span>00000001; 		<span class="keyword">if</span>(ch2 &gt; <span class="number">254</span>) directions &amp;= ~<span class="number">0B</span>00000010;</div><div class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(ch2 &lt; <span class="number">1</span>) directions |= <span class="number">0B</span>00000010; 		<span class="keyword">if</span>(ch3 &gt; <span class="number">254</span>) directions &amp;= ~<span class="number">0B</span>00000100;</div><div class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(ch3 &lt; <span class="number">1</span>) directions |= <span class="number">0B</span>00000100; 		<span class="keyword">if</span>(ch4 &gt; <span class="number">254</span>) directions &amp;= ~<span class="number">0B</span>00001000;</div><div class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(ch4 &lt; <span class="number">1</span>) directions |= <span class="number">0B</span>00001000; 		<span class="keyword">if</span>(ch5 &gt; <span class="number">254</span>) directions &amp;= ~<span class="number">0B</span>00010000;</div><div class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(ch5 &lt; <span class="number">1</span>) directions |= <span class="number">0B</span>00010000;</div><div class="line"></div><div class="line">		<span class="number">_</span>delay_ms(DELAY_MS);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Like all AVR-LibC programs, the main() function is divided into a setup phase,
which runs once at the time of power-up, and a loop phase, which runs after
setup as long as power is supplied. The setup function here sets the five LED
channels to a starting brightness with an interval determined by the macro
TIME_OFFSET, so-named because it simulates the amount of time by which each LED
leads the one “behind” it in the circular brightness pattern.</p>
<p>Then the loop logic uses a one-bit “direction” flag to decide whether to
increment or decrement the brightness of each channel, and finally a comparison
checks whether the direction needs to reverse (in case the LED is at minimum or
maximum brightness). The loop delays by time DELAY_MS, in milliseconds, and
starts again.</p>
<p>That’s it! Beyond setting up the timer details with the lines</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">TCCR0B |= (<span class="number">1</span> &lt;&lt; CS00); <span class="comment">// disable timer prescale (=clock rate)</span></div><div class="line">TIMSK0 |= (<span class="number">1</span> &lt;&lt; TOIE0); <span class="comment">// enable timer overflow interrupt specifically</span></div><div class="line"></div><div class="line">sei(); <span class="comment">// enable interrupts in general</span></div></pre></td></tr></table></figure>
<p>as given in the ATtiny13 datasheet, the main() function and the ISR together
handle everything the program has to do to make pretty blinky lights.</p>
<p>There is one more step, actually. By default, the ATtiny13 ships with a 1/8th
clock prescaler enabled, a fuse called “CKDIV8” or “clock divide 8.” To make the
timer count quickly enough for the PWM to be invisible to the human eye, we need
to disable this clock divisor. To do so, we must run the command</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="string">"avrdude -c usbtiny -p t13 -U lfuse:w:0x7A:m"</span></div></pre></td></tr></table></figure>
<p>instructing avrdude to write 0x7A to the low fuse. This is the same as the
default low fuse value in every way but the CKDIV8 bit, which has been disabled.</p>
<p>The complete code:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">* Stardweeny Source Code</div><div class="line">* Author: Travis Geis</div><div class="line">* Version: 1</div><div class="line">* Date: January 2012</div><div class="line">* URL: http://zenlogic.org/</div><div class="line">*</div><div class="line">* file: main.c</div><div class="line">*</div><div class="line">* The Stardweeny project runs five channels of software PWM to</div><div class="line">* control the five individual LEDs in the points of a paper star.</div><div class="line">*</div><div class="line">* Inspired by and dedicated to Linda Geis.</div><div class="line">*</div><div class="line">* For this code to work correctly, lfuse = 0x7A. (Disabling CKDIV8)</div><div class="line">* Run the command "avrdude -c usbtiny -p t13 -U lfuse:w:0x7A:m"</div><div class="line">*/</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> F_CPU 9.6E6L <span class="comment">/* CPU Freq. Must come before delay.h include. 9.6MHz */</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span>  <span class="comment">/* For data types */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span>  <span class="comment">/* Register and port definitions */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span>  <span class="comment">/* Busy-wait delay functions */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span>  <span class="comment">/* Exposes timers, counters and ISR functions */</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> CH1_PIN PB0 <span class="comment">/* Bind output channels to specific PortB pins. This depends on schematic. */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> CH2_PIN PB1</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> CH3_PIN PB2</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> CH4_PIN PB3</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> CH5_PIN PB4</span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> TIME_OFFSET 50</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> DELAY_MS 3</span></div><div class="line"></div><div class="line"><span class="keyword">uint8_t</span> ch1, ch2, ch3, ch4, ch5; <span class="comment">/* The one-byte PWM level of each channel */</span></div><div class="line"><span class="keyword">uint8_t</span> directions = <span class="number">0xFF</span>;</div><div class="line"><span class="comment">/*</span></div><div class="line">This one-byte flag holds five channel direction bit flags</div><div class="line">0x [nothing] [nothing] [nothing] [ch5] [ch4] [ch3] [ch2] [ch1]</div><div class="line">*/</div><div class="line"></div><div class="line"><span class="keyword">volatile</span> <span class="keyword">uint8_t</span> ISRcounter = <span class="number">0</span>; <span class="comment">/* Count the number of times the ISR has run */</span></div><div class="line"><span class="keyword">uint8_t</span> timeCount;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line">* int main(void):</div><div class="line">*</div><div class="line">* The main function runs automatically when the AVR powers up.</div><div class="line">* It never returns, and so dispatches all other actions for the</div><div class="line">* microcontroller.</div><div class="line">*</div><div class="line">* The goal is to make a sinusoidal light intensity with time.</div><div class="line">*</div><div class="line">*/</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="comment">/* Setup */</span></div><div class="line">	ch1 = <span class="number">0</span>;</div><div class="line">	ch2 = TIME_OFFSET;</div><div class="line">	ch3 = <span class="number">2</span> * TIME_OFFSET;</div><div class="line">	ch4 = <span class="number">3</span> * TIME_OFFSET;</div><div class="line">	ch5 = <span class="number">4</span> * TIME_OFFSET;</div><div class="line"></div><div class="line">	DDRB = <span class="number">0xFF</span>; <span class="comment">//Every PORTB pin is output</span></div><div class="line">	PORTB = <span class="number">0x00</span>; <span class="comment">//Start with every pin low</span></div><div class="line"></div><div class="line">	TCCR0B |= (<span class="number">1</span> &lt;&lt; CS00); <span class="comment">// disable timer prescale (=clock rate)</span></div><div class="line">	TIMSK0 |= (<span class="number">1</span> &lt;&lt; TOIE0); <span class="comment">// enable timer overflow interrupt specifically 	 	sei(); // enable interrupts in general 	 	/* Loop */ 	while(1)&#123; 		if(directions &amp; 1) ch1++; 		else ch1--; 		if(directions &amp; 0B00000010) ch2++; 		else ch2--; 		if(directions &amp; 0B00000100) ch3++; 		else ch3--; 		if(directions &amp; 0B00001000) ch4++; 		else ch4--; 		if(directions &amp; 0B00010000) ch5++; 		else ch5--; 		if(ch1 &gt; 254) directions &amp;= ~0B00000001;</span></div><div class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(ch1 &lt; <span class="number">1</span>) directions |= <span class="number">0B</span>00000001; 		<span class="keyword">if</span>(ch2 &gt; <span class="number">254</span>) directions &amp;= ~<span class="number">0B</span>00000010;</div><div class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(ch2 &lt; <span class="number">1</span>) directions |= <span class="number">0B</span>00000010; 		<span class="keyword">if</span>(ch3 &gt; <span class="number">254</span>) directions &amp;= ~<span class="number">0B</span>00000100;</div><div class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(ch3 &lt; <span class="number">1</span>) directions |= <span class="number">0B</span>00000100; 		<span class="keyword">if</span>(ch4 &gt; <span class="number">254</span>) directions &amp;= ~<span class="number">0B</span>00001000;</div><div class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(ch4 &lt; <span class="number">1</span>) directions |= <span class="number">0B</span>00001000; 		<span class="keyword">if</span>(ch5 &gt; <span class="number">254</span>) directions &amp;= ~<span class="number">0B</span>00010000;</div><div class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(ch5 &lt; <span class="number">1</span>) directions |= <span class="number">0B</span>00010000;</div><div class="line"></div><div class="line">		<span class="number">_</span>delay_ms(DELAY_MS);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">/*</span></div><div class="line">* The ISR is responsible for toggling the states of the five output channels</div><div class="line">* based on the current global variables for the desired brightness levels.</div><div class="line">* Because the brightnesses (ch1 ... ch5) are single-byte values, the range</div><div class="line">* of values is 0 to 255\. Thus the ISR needs to restart its counting cycle every</div><div class="line">* 256th time it is called.</div><div class="line">*</div><div class="line">* To avoid undesired wiggle on the PWM, the ISR updates evey channel's pin</div><div class="line">* every time it runs. It should take the same number of cycles every time.</div><div class="line">* The duty period of the PWM is the first section. Thus the LED goes ON then OFF.</div><div class="line">*/</div><div class="line">ISR(TIM0_OVF_vect)</div><div class="line">&#123;</div><div class="line">	<span class="keyword">if</span>(ISRcounter &lt; ch1) PORTB |= (<span class="number">1</span> &lt;&lt; CH1_PIN); <span class="comment">//Write the ch1 pin high</span></div><div class="line">	<span class="keyword">else</span> PORTB &amp;= ~(<span class="number">1</span> &lt;&lt; CH1_PIN); <span class="comment">//Write the ch1 pin low</span></div><div class="line"></div><div class="line">	<span class="keyword">if</span>(ISRcounter &lt; ch2) PORTB |= (<span class="number">1</span> &lt;&lt; CH2_PIN);</div><div class="line">	<span class="keyword">else</span> PORTB &amp;= ~(<span class="number">1</span> &lt;&lt; CH2_PIN);</div><div class="line"></div><div class="line">	<span class="keyword">if</span>(ISRcounter &lt; ch3) PORTB |= (<span class="number">1</span> &lt;&lt; CH3_PIN);</div><div class="line">	<span class="keyword">else</span> PORTB &amp;= ~(<span class="number">1</span> &lt;&lt; CH3_PIN);</div><div class="line"></div><div class="line">	<span class="keyword">if</span>(ISRcounter &lt; ch4) PORTB |= (<span class="number">1</span> &lt;&lt; CH4_PIN);</div><div class="line">	<span class="keyword">else</span> PORTB &amp;= ~(<span class="number">1</span> &lt;&lt; CH4_PIN);</div><div class="line"></div><div class="line">	<span class="keyword">if</span>(ISRcounter &lt; ch5) PORTB |= (<span class="number">1</span> &lt;&lt; CH5_PIN);</div><div class="line">	<span class="keyword">else</span> PORTB &amp;= ~(<span class="number">1</span> &lt;&lt; CH5_PIN);</div><div class="line"></div><div class="line">	ISRcounter++;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Feel free to use the code any way you want. Have fun!</p>
</article><nav id="pagination"><ul class="pagination justify-content-center"><li class="page-item"><a href="../../20/stardweeny-evolves-into-startiny-pcbs-sent-to-production/" class="page-link">&larr; Prev</a></li><l class="page-item"><a href="../../../../2011/11/23/more-portable-power/" class="page-link">Next &rarr;</a></l></ul></nav></div></div><script src="/js/boxy.js"></script></body></html>