<!DOCTYPE html><html lang="en"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1"><title>Software PWM on the ATtiny13 - travisgeis.com</title><link rel="stylesheet" type="text/css" href="/semantic/dist/semantic.min.css">
<script src="https://code.jquery.com/jquery-3.1.1.min.js" integrity="sha256-hVVnYaiADRTO2PzUGmuLJr8BLUSjGIZsDYGmIJLv2b8=" crossorigin="anonymous"></script>
<script src="/semantic/dist/semantic.min.js"></script><link href="https://fonts.googleapis.com/css?family=Spectral|Rubik|Anonymous+Pro" rel="stylesheet"><!-- favicon set from favicomatic.com -->
<meta name="application-name" content="travisgeis.com">
<link rel="apple-touch-icon-precomposed" sizes="57x57" href="/favicons/apple-touch-icon-57x57.png">
<link rel="apple-touch-icon-precomposed" sizes="114x114" href="/favicons/apple-touch-icon-114x114.png">
<link rel="apple-touch-icon-precomposed" sizes="72x72" href="/favicons/apple-touch-icon-72x72.png">
<link rel="apple-touch-icon-precomposed" sizes="144x144" href="/favicons/apple-touch-icon-144x144.png">
<link rel="apple-touch-icon-precomposed" sizes="60x60" href="/favicons/apple-touch-icon-60x60.png">
<link rel="apple-touch-icon-precomposed" sizes="120x120" href="/favicons/apple-touch-icon-120x120.png">
<link rel="apple-touch-icon-precomposed" sizes="76x76" href="/favicons/apple-touch-icon-76x76.png">
<link rel="apple-touch-icon-precomposed" sizes="152x152" href="/favicons/apple-touch-icon-152x152.png">
<link rel="icon" type="image/png" href="/favicons/favicon-196x196.png" sizes="196x196">
<link rel="icon" type="image/png" href="/favicons/favicon-96x96.png" sizes="96x96">
<link rel="icon" type="image/png" href="/favicons/favicon-32x32.png" sizes="32x32">
<link rel="icon" type="image/png" href="/favicons/favicon-16x16.png" sizes="16x16">
<link rel="icon" type="image/png" href="/favicons/favicon-128.png" sizes="128x128">
<meta name="msapplication-TileColor" content="#FFFFFF">
<meta name="msapplication-TileImage" content="/favicons/mstile-144x144.png">
<meta name="msapplication-square70x70logo" content="/favicons/mstile-70x70.png">
<meta name="msapplication-square150x150logo" content="/favicons/mstile-150x150.png">
<meta name="msapplication-wide310x150logo" content="/favicons/mstile-310x150.png">
<meta name="msapplication-square310x310logo" content="/favicons/mstile-310x310.png">
<script data-goatcounter="https://ottobonn.goatcounter.com/count" async src="//gc.zgo.at/count.js"></script><link rel="stylesheet" href="/css/boxy.css"><link rel="alternate" href="atom.xml" title="travisgeis.com" type="application/atom+xml">
<link rel="alternate" href="rss2.xml" title="travisgeis.com" type="application/rss+xml">
</head><body><div id="page" class="ui container"><div id="menu"><div class="ui stackable secondary variable item menu"><a href="/" class="item"><i class="icon home"></i>travisgeis.com</a><a href="/contact" class="item"><i class="icon comments"></i>Contact</a></div></div><div id="titles"><h1 class="ui huge header">Software PWM on the ATtiny13</h1><h3 class="ui header">11 January, 2012</h3></div><div id="content"><article id="post"><a href="/uploads/2012/01/IMG_2929-e1326866475822.jpg"><img src="/uploads/2012/01/body-IMG_2929-e1326866475822.jpg" alt="A first go at the Stardweeny using an ATtiny13" title="Stardweeny ATtiny First Prototype"></a>
<p>This year for the holidays I created a little dynamic ornament with five
channels of independent LED light. The prototype, which had to be finished in a
matter of days, used an Ardweeny board from Solarbotics. The Ardweeny is based
on the ATmega328, a great chip with more than five hardware channels for PWM
(pulse-width modulation). While I love the ATmega chips, they get a bit pricey
at $5 apiece just to drive some LEDs.</p>
<p>I was shopping on Digi-Key for alternatives and decided to try a couple of
ATtiny13 microcontrollers. The ATtiny13 is a small, low-power AVR with the
standard 8-bit core size, and conveniently comes with a 9.6-MHz internal RC
oscillator. Because the ATtiny has an internal oscillator, I knew I could keep
my hardware very minimal and thus very small, a requirement for the small paper
ornament I was hoping to build.</p>
<p>The problem is that the ATtiny13 has only one PWM output. If I used only its
hardware functionality, I would get one channel of control, where I needed five.
To solution is to implement a simple software PWM. In this post I describe my
process of getting software PWM (and embedded C programming in general) working
on the ATtiny13.</p>
<a id="more"></a>
<p>The first step with programming any part is reading the datasheet [link]. The
Attiny13 comes with 1KB of internal flash memory for programs. When I ordered it
this sounded plenty large for my purposes, but I forgot to account for the heavy
Arduino libraries I’m used to using, whose needed functionality I would have to
implement myself in the code. 1KB turns out to feel like a tiny amount of space.</p>
<p>1KB is too small to hold the floating-point math libraries of AVR-LibC, the C
library I use for AVR programs. It’s also too small to hold the math.h library,
which includes the trigonometry functions. In my ‘328-based prototype I used a
sin() function to calculate the brightness levels of the light channels, to give
a soothing light pulsation. That won’t be an option on the tiny13.</p>
<p>I had a lot of trouble getting started with C on the ATtiny. It’s not too
complicated once you get going, though.</p>
<h2 id="Implementing-Software-PWM"><a href="#Implementing-Software-PWM" class="headerlink" title="Implementing Software PWM"></a>Implementing Software PWM</h2><p>Software PWM uses an inbuilt functionality of the microcontroller called a
timer. The timer counts off clock cycles, and when it reaches a certain point,
in this case its maximum value of 255 (the max value of a single unsigned byte),
the timer triggers an interrupt.</p>
<p>The interrupt is important precisely because it interrupts the running code.
Specifically, it tells the microcontroller to jump to a predefined location in
program memory, execute the instructions there, and then return to the main
routine. For software-based PWM, the timer interrupt is perfect. It frees up the
main program logic by periodically and consistently executing the same function,
called an Interrupt Service Routine.</p>
<p>So the desired program flow looks like this:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">main()&#123;</span><br><span class="line">	loop infinitely, changing the output levels</span><br><span class="line">	accordingly.</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ISR()&#123;</span><br><span class="line">	run now <span class="keyword">and</span> then, twiddling the hardware</span><br><span class="line">	outputs to correspond with the output levels</span><br><span class="line">	<span class="built_in">set</span> in main</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The main function in my case was supposed to set the output level of each of
five LEDs such that one LED would “lead” the others in a gentle up-down
pulsation. The ISR would be responsible for dealing with the actual on-off
settings of the LEDs.</p>
<p>For my project I chose a PWM resolution of one byte, or eight bits. A byte
allows for 256 possible output levels, plenty more than the eye can see in
brightness gradation. A resolution of 256 means that there are 256 “time slots”
wherein an LED can turn on or off.</p>
<p>For example, if the brightness of the LED is supposed to be 255, it is on from
time slot “0” all the way to time slot “255”—in other words, all the time. If
the brightness is 0, the LED is off for every cycle. If the brightness is 100,
the LED is on for the first hundred cycles, then off for the remaining 155.</p>
<p>The resulting output is not smooth, but a series of full-on and full-off
positions that, to the relatively slow human eye, average together to some
intermediate brightness. So, now we know roughly what the ISR should do:</p>
<ol>
<li>Read the desired brightness level of an LED, in the form of a global variable.</li>
<li>Read the current progress through the 256 cycles</li>
<li><p>Compare the brightness level to the current progress</p>
</li>
<li><p>If the progress is lower than the desired on-time, turn the LED on.</p>
</li>
<li>If the progress is past the desired on-time, turn the LED off.4.  Increment
the progress by one. AVR-LibC says that the ISR for the timer interrupt on the
tiny13 has the signature</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ISR(TIM0_OVF_vect)&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>The TIM0_OVF_vect parameter indicates that this ISR (potentially one of several)
is specifically for interrupts triggered by a TIMER0 overflow.</p>
<p>Given the pin number of each LED channel, and the brightness level desired, the
ISR body looks like:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ISR(TIM0_OVF_vect)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(ISRcounter &lt; ch1) PORTB |= (<span class="number">1</span> &lt;&lt; CH1_PIN); <span class="comment">//Write the ch1 pin high</span></span><br><span class="line">	<span class="keyword">else</span> PORTB &amp;= ~(<span class="number">1</span> &lt;&lt; CH1_PIN); <span class="comment">//Write the ch1 pin low</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(ISRcounter &lt; ch2) PORTB |= (<span class="number">1</span> &lt;&lt; CH2_PIN);</span><br><span class="line">	<span class="keyword">else</span> PORTB &amp;= ~(<span class="number">1</span> &lt;&lt; CH2_PIN);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(ISRcounter &lt; ch3) PORTB |= (<span class="number">1</span> &lt;&lt; CH3_PIN);</span><br><span class="line">	<span class="keyword">else</span> PORTB &amp;= ~(<span class="number">1</span> &lt;&lt; CH3_PIN);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(ISRcounter &lt; ch4) PORTB |= (<span class="number">1</span> &lt;&lt; CH4_PIN);</span><br><span class="line">	<span class="keyword">else</span> PORTB &amp;= ~(<span class="number">1</span> &lt;&lt; CH4_PIN);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(ISRcounter &lt; ch5) PORTB |= (<span class="number">1</span> &lt;&lt; CH5_PIN);</span><br><span class="line">	<span class="keyword">else</span> PORTB &amp;= ~(<span class="number">1</span> &lt;&lt; CH5_PIN);</span><br><span class="line"></span><br><span class="line">	ISRcounter++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>where <code>ch1, ch2, ..., ch5</code> are the single-byte output levels of each channel, and
<code>CH1_PIN, CH2_PIN, ..., CH5_PIN</code> are the pin numbers for each channel.</p>
<p>The ISR is actually very simple:</p>
<p>ISRcounter holds the current count of ISR runs (0 to 255). For each channel, if
the ISRcounter is less than the brightness level desired for that channel, write
the LED HIGH (<code>PORTB |= (1 &lt;&lt; pinNumber)</code>). Once the counter exceeds the desired
brightness level, keep writing the LED LOW (<code>PORTB &amp;= ~(1 &lt;&lt; pinNumber)</code>). So,
in effect, the brightness level byte is simply the ON-time of the LED, out of
255.</p>
<p>The rest of the code can now fall into place:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> F_CPU 9.6E6L <span class="comment">/* CPU Freq. Must come before delay.h include. 9.6MHz */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>  <span class="comment">/* For data types */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>  <span class="comment">/* Register and port definitions */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>  <span class="comment">/* Busy-wait delay functions */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>  <span class="comment">/* Exposes timers, counters and ISR functions */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CH1_PIN PB0 <span class="comment">/* Bind output channels to specific PortB pins. This depends on schematic. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CH2_PIN PB1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CH3_PIN PB2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CH4_PIN PB3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CH5_PIN PB4</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TIME_OFFSET 50</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DELAY_MS 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">uint8_t</span> ch1, ch2, ch3, ch4, ch5; <span class="comment">/* The one-byte PWM level of each channel */</span></span><br><span class="line"><span class="keyword">uint8_t</span> directions = <span class="number">0xFF</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">This one-byte flag holds five channel direction bit flags</span></span><br><span class="line"><span class="comment">0x [nothing] [nothing] [nothing] [ch5] [ch4] [ch3] [ch2] [ch1]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">uint8_t</span> ISRcounter = <span class="number">0</span>; <span class="comment">/* Count the number of times the ISR has run */</span></span><br><span class="line"><span class="keyword">uint8_t</span> timeCount;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/* Setup */</span></span><br><span class="line">	ch1 = <span class="number">0</span>;</span><br><span class="line">	ch2 = TIME_OFFSET;</span><br><span class="line">	ch3 = <span class="number">2</span> * TIME_OFFSET;</span><br><span class="line">	ch4 = <span class="number">3</span> * TIME_OFFSET;</span><br><span class="line">	ch5 = <span class="number">4</span> * TIME_OFFSET;</span><br><span class="line"></span><br><span class="line">	DDRB = <span class="number">0xFF</span>; <span class="comment">//Every PORTB pin is output</span></span><br><span class="line">	PORTB = <span class="number">0x00</span>; <span class="comment">//Start with every pin low</span></span><br><span class="line"></span><br><span class="line">	TCCR0B |= (<span class="number">1</span> &lt;&lt; CS00); <span class="comment">// disable timer prescale (=clock rate)</span></span><br><span class="line">	TIMSK0 |= (<span class="number">1</span> &lt;&lt; TOIE0); <span class="comment">// enable timer overflow interrupt specifically 	sei(); // enable interrupts in general 	/* Loop */ 	while(1)&#123; 		if(directions &amp; 1) ch1++; 		else ch1--; 		if(directions &amp; 0B00000010) ch2++; 		else ch2--; 		if(directions &amp; 0B00000100) ch3++; 		else ch3--; 		if(directions &amp; 0B00001000) ch4++; 		else ch4--; 		if(directions &amp; 0B00010000) ch5++; 		else ch5--; 		if(ch1 &gt; 254) directions &amp;= ~0B00000001;</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(ch1 &lt; <span class="number">1</span>) directions |= <span class="number">0B</span>00000001; 		<span class="keyword">if</span>(ch2 &gt; <span class="number">254</span>) directions &amp;= ~<span class="number">0B</span>00000010;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(ch2 &lt; <span class="number">1</span>) directions |= <span class="number">0B</span>00000010; 		<span class="keyword">if</span>(ch3 &gt; <span class="number">254</span>) directions &amp;= ~<span class="number">0B</span>00000100;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(ch3 &lt; <span class="number">1</span>) directions |= <span class="number">0B</span>00000100; 		<span class="keyword">if</span>(ch4 &gt; <span class="number">254</span>) directions &amp;= ~<span class="number">0B</span>00001000;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(ch4 &lt; <span class="number">1</span>) directions |= <span class="number">0B</span>00001000; 		<span class="keyword">if</span>(ch5 &gt; <span class="number">254</span>) directions &amp;= ~<span class="number">0B</span>00010000;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(ch5 &lt; <span class="number">1</span>) directions |= <span class="number">0B</span>00010000;</span><br><span class="line"></span><br><span class="line">		_delay_ms(DELAY_MS);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Like all AVR-LibC programs, the main() function is divided into a setup phase,
which runs once at the time of power-up, and a loop phase, which runs after
setup as long as power is supplied. The setup function here sets the five LED
channels to a starting brightness with an interval determined by the macro
TIME_OFFSET, so-named because it simulates the amount of time by which each LED
leads the one “behind” it in the circular brightness pattern.</p>
<p>Then the loop logic uses a one-bit “direction” flag to decide whether to
increment or decrement the brightness of each channel, and finally a comparison
checks whether the direction needs to reverse (in case the LED is at minimum or
maximum brightness). The loop delays by time DELAY_MS, in milliseconds, and
starts again.</p>
<p>That’s it! Beyond setting up the timer details with the lines</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TCCR0B |= (<span class="number">1</span> &lt;&lt; CS00); <span class="comment">// disable timer prescale (=clock rate)</span></span><br><span class="line">TIMSK0 |= (<span class="number">1</span> &lt;&lt; TOIE0); <span class="comment">// enable timer overflow interrupt specifically</span></span><br><span class="line"></span><br><span class="line">sei(); <span class="comment">// enable interrupts in general</span></span><br></pre></td></tr></table></figure>
<p>as given in the ATtiny13 datasheet, the main() function and the ISR together
handle everything the program has to do to make pretty blinky lights.</p>
<p>There is one more step, actually. By default, the ATtiny13 ships with a 1/8th
clock prescaler enabled, a fuse called “CKDIV8” or “clock divide 8.” To make the
timer count quickly enough for the PWM to be invisible to the human eye, we need
to disable this clock divisor. To do so, we must run the command</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"avrdude -c usbtiny -p t13 -U lfuse:w:0x7A:m"</span></span><br></pre></td></tr></table></figure>
<p>instructing avrdude to write 0x7A to the low fuse. This is the same as the
default low fuse value in every way but the CKDIV8 bit, which has been disabled.</p>
<p>The complete code:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Stardweeny Source Code</span></span><br><span class="line"><span class="comment">* Author: Travis Geis</span></span><br><span class="line"><span class="comment">* Version: 1</span></span><br><span class="line"><span class="comment">* Date: January 2012</span></span><br><span class="line"><span class="comment">* URL: http://zenlogic.org/</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* file: main.c</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* The Stardweeny project runs five channels of software PWM to</span></span><br><span class="line"><span class="comment">* control the five individual LEDs in the points of a paper star.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* Inspired by and dedicated to Linda Geis.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* For this code to work correctly, lfuse = 0x7A. (Disabling CKDIV8)</span></span><br><span class="line"><span class="comment">* Run the command "avrdude -c usbtiny -p t13 -U lfuse:w:0x7A:m"</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> F_CPU 9.6E6L <span class="comment">/* CPU Freq. Must come before delay.h include. 9.6MHz */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>  <span class="comment">/* For data types */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>  <span class="comment">/* Register and port definitions */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>  <span class="comment">/* Busy-wait delay functions */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>  <span class="comment">/* Exposes timers, counters and ISR functions */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CH1_PIN PB0 <span class="comment">/* Bind output channels to specific PortB pins. This depends on schematic. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CH2_PIN PB1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CH3_PIN PB2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CH4_PIN PB3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CH5_PIN PB4</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TIME_OFFSET 50</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DELAY_MS 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">uint8_t</span> ch1, ch2, ch3, ch4, ch5; <span class="comment">/* The one-byte PWM level of each channel */</span></span><br><span class="line"><span class="keyword">uint8_t</span> directions = <span class="number">0xFF</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">This one-byte flag holds five channel direction bit flags</span></span><br><span class="line"><span class="comment">0x [nothing] [nothing] [nothing] [ch5] [ch4] [ch3] [ch2] [ch1]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">uint8_t</span> ISRcounter = <span class="number">0</span>; <span class="comment">/* Count the number of times the ISR has run */</span></span><br><span class="line"><span class="keyword">uint8_t</span> timeCount;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* int main(void):</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* The main function runs automatically when the AVR powers up.</span></span><br><span class="line"><span class="comment">* It never returns, and so dispatches all other actions for the</span></span><br><span class="line"><span class="comment">* microcontroller.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* The goal is to make a sinusoidal light intensity with time.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/* Setup */</span></span><br><span class="line">	ch1 = <span class="number">0</span>;</span><br><span class="line">	ch2 = TIME_OFFSET;</span><br><span class="line">	ch3 = <span class="number">2</span> * TIME_OFFSET;</span><br><span class="line">	ch4 = <span class="number">3</span> * TIME_OFFSET;</span><br><span class="line">	ch5 = <span class="number">4</span> * TIME_OFFSET;</span><br><span class="line"></span><br><span class="line">	DDRB = <span class="number">0xFF</span>; <span class="comment">//Every PORTB pin is output</span></span><br><span class="line">	PORTB = <span class="number">0x00</span>; <span class="comment">//Start with every pin low</span></span><br><span class="line"></span><br><span class="line">	TCCR0B |= (<span class="number">1</span> &lt;&lt; CS00); <span class="comment">// disable timer prescale (=clock rate)</span></span><br><span class="line">	TIMSK0 |= (<span class="number">1</span> &lt;&lt; TOIE0); <span class="comment">// enable timer overflow interrupt specifically 	 	sei(); // enable interrupts in general 	 	/* Loop */ 	while(1)&#123; 		if(directions &amp; 1) ch1++; 		else ch1--; 		if(directions &amp; 0B00000010) ch2++; 		else ch2--; 		if(directions &amp; 0B00000100) ch3++; 		else ch3--; 		if(directions &amp; 0B00001000) ch4++; 		else ch4--; 		if(directions &amp; 0B00010000) ch5++; 		else ch5--; 		if(ch1 &gt; 254) directions &amp;= ~0B00000001;</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(ch1 &lt; <span class="number">1</span>) directions |= <span class="number">0B</span>00000001; 		<span class="keyword">if</span>(ch2 &gt; <span class="number">254</span>) directions &amp;= ~<span class="number">0B</span>00000010;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(ch2 &lt; <span class="number">1</span>) directions |= <span class="number">0B</span>00000010; 		<span class="keyword">if</span>(ch3 &gt; <span class="number">254</span>) directions &amp;= ~<span class="number">0B</span>00000100;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(ch3 &lt; <span class="number">1</span>) directions |= <span class="number">0B</span>00000100; 		<span class="keyword">if</span>(ch4 &gt; <span class="number">254</span>) directions &amp;= ~<span class="number">0B</span>00001000;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(ch4 &lt; <span class="number">1</span>) directions |= <span class="number">0B</span>00001000; 		<span class="keyword">if</span>(ch5 &gt; <span class="number">254</span>) directions &amp;= ~<span class="number">0B</span>00010000;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(ch5 &lt; <span class="number">1</span>) directions |= <span class="number">0B</span>00010000;</span><br><span class="line"></span><br><span class="line">		_delay_ms(DELAY_MS);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* The ISR is responsible for toggling the states of the five output channels</span></span><br><span class="line"><span class="comment">* based on the current global variables for the desired brightness levels.</span></span><br><span class="line"><span class="comment">* Because the brightnesses (ch1 ... ch5) are single-byte values, the range</span></span><br><span class="line"><span class="comment">* of values is 0 to 255\. Thus the ISR needs to restart its counting cycle every</span></span><br><span class="line"><span class="comment">* 256th time it is called.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* To avoid undesired wiggle on the PWM, the ISR updates evey channel's pin</span></span><br><span class="line"><span class="comment">* every time it runs. It should take the same number of cycles every time.</span></span><br><span class="line"><span class="comment">* The duty period of the PWM is the first section. Thus the LED goes ON then OFF.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">ISR(TIM0_OVF_vect)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(ISRcounter &lt; ch1) PORTB |= (<span class="number">1</span> &lt;&lt; CH1_PIN); <span class="comment">//Write the ch1 pin high</span></span><br><span class="line">	<span class="keyword">else</span> PORTB &amp;= ~(<span class="number">1</span> &lt;&lt; CH1_PIN); <span class="comment">//Write the ch1 pin low</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(ISRcounter &lt; ch2) PORTB |= (<span class="number">1</span> &lt;&lt; CH2_PIN);</span><br><span class="line">	<span class="keyword">else</span> PORTB &amp;= ~(<span class="number">1</span> &lt;&lt; CH2_PIN);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(ISRcounter &lt; ch3) PORTB |= (<span class="number">1</span> &lt;&lt; CH3_PIN);</span><br><span class="line">	<span class="keyword">else</span> PORTB &amp;= ~(<span class="number">1</span> &lt;&lt; CH3_PIN);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(ISRcounter &lt; ch4) PORTB |= (<span class="number">1</span> &lt;&lt; CH4_PIN);</span><br><span class="line">	<span class="keyword">else</span> PORTB &amp;= ~(<span class="number">1</span> &lt;&lt; CH4_PIN);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(ISRcounter &lt; ch5) PORTB |= (<span class="number">1</span> &lt;&lt; CH5_PIN);</span><br><span class="line">	<span class="keyword">else</span> PORTB &amp;= ~(<span class="number">1</span> &lt;&lt; CH5_PIN);</span><br><span class="line"></span><br><span class="line">	ISRcounter++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Feel free to use the code any way you want. Have fun!</p>
<script src="https://utteranc.es/client.js" repo="ottobonn/travisgeis.com" issue-term="Software PWM on the ATtiny13" label="comment" theme="github-light" crossorigin="anonymous" async></script></article><nav id="pagination"><div class="ui fluid variable item pagination menu"><a href="../../20/stardweeny-evolves-into-startiny-pcbs-sent-to-production/" class="item"><i class="arrow circle left icon"></i>Previous</a><a href="../../../../2011/11/23/more-portable-power/" class="item"><i class="arrow circle right icon"></i>Next</a></div></nav></div></div><div id="footer"><div class="ui stackable secondary menu"><a href="/rss2.xml" class="item"><i class="rss icon"></i>RSS</a><a href="/atom.xml" class="item"><i class="rss icon"></i>Atom</a></div></div></body></html>