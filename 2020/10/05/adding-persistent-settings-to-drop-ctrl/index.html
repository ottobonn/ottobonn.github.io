<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1"><title>Adding Persistent Settings to Drop CTRL - travisgeis.com</title><link rel="stylesheet" type="text/css" href="/semantic/dist/semantic.min.css">
<script src="https://code.jquery.com/jquery-3.1.1.min.js" integrity="sha256-hVVnYaiADRTO2PzUGmuLJr8BLUSjGIZsDYGmIJLv2b8=" crossorigin="anonymous"></script>
<script src="/semantic/dist/semantic.min.js"></script>
<script type="module" src="/js/stl-viewer/stl-viewer.js"></script><link href="https://fonts.googleapis.com/css?family=Spectral|Rubik|Anonymous+Pro" rel="stylesheet"><!-- favicon set from favicomatic.com -->
<meta name="application-name" content="travisgeis.com"/>
<link rel="apple-touch-icon-precomposed" sizes="57x57" href="/favicons/apple-touch-icon-57x57.png" />
<link rel="apple-touch-icon-precomposed" sizes="114x114" href="/favicons/apple-touch-icon-114x114.png" />
<link rel="apple-touch-icon-precomposed" sizes="72x72" href="/favicons/apple-touch-icon-72x72.png" />
<link rel="apple-touch-icon-precomposed" sizes="144x144" href="/favicons/apple-touch-icon-144x144.png" />
<link rel="apple-touch-icon-precomposed" sizes="60x60" href="/favicons/apple-touch-icon-60x60.png" />
<link rel="apple-touch-icon-precomposed" sizes="120x120" href="/favicons/apple-touch-icon-120x120.png" />
<link rel="apple-touch-icon-precomposed" sizes="76x76" href="/favicons/apple-touch-icon-76x76.png" />
<link rel="apple-touch-icon-precomposed" sizes="152x152" href="/favicons/apple-touch-icon-152x152.png" />
<link rel="icon" type="image/png" href="/favicons/favicon-196x196.png" sizes="196x196" />
<link rel="icon" type="image/png" href="/favicons/favicon-96x96.png" sizes="96x96" />
<link rel="icon" type="image/png" href="/favicons/favicon-32x32.png" sizes="32x32" />
<link rel="icon" type="image/png" href="/favicons/favicon-16x16.png" sizes="16x16" />
<link rel="icon" type="image/png" href="/favicons/favicon-128.png" sizes="128x128" />
<meta name="msapplication-TileColor" content="#FFFFFF" />
<meta name="msapplication-TileImage" content="/favicons/mstile-144x144.png" />
<meta name="msapplication-square70x70logo" content="/favicons/mstile-70x70.png" />
<meta name="msapplication-square150x150logo" content="/favicons/mstile-150x150.png" />
<meta name="msapplication-wide310x150logo" content="/favicons/mstile-310x150.png" />
<meta name="msapplication-square310x310logo" content="/favicons/mstile-310x310.png" /><link rel="stylesheet" href="/css/boxy.css"><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="atom.xml" title="travisgeis.com" type="application/atom+xml">
<link rel="alternate" href="rss2.xml" title="travisgeis.com" type="application/rss+xml">
</head><body><div id="page" class="ui container"><div id="menu"><div class="ui stackable secondary variable item menu"><a href="/" class="item"><i class="icon home"></i>travisgeis.com</a><a href="/contact" class="item"><i class="icon comments"></i>Contact</a></div></div><div id="titles"><h1 class="ui huge header">Adding Persistent Settings to Drop CTRL</h1><h3 class="ui header">5 October, 2020</h3></div><div id="content"><article id="post"><!-- <div class="ui message">
  For more thoughts on the Drop CTRL in general, check out my full review.
</div> -->
<p>I recently bought a <a href="https://drop.com/buy/drop-ctrl-high-profile-mechanical-keyboard">Drop CTRL keyboard</a> and I’m quite pleased, but after a few days I noticed that every time I unplugged it, it would reset itself to the default LED animation. I did some digging into the firmware, a <a href="https://github.com/Massdrop/qmk_firmware">variant</a> of the popular <a href="https://qmk.fm/">QMK</a>, and discovered that the keyboard’s persistent storage driver is just stubbed out as an array in memory! By default, when the keyboard loses power, it forgets all the settings configured while it was on.</p>
<p>This article will go through the technical details of what needs to happen to get this keyboard to remember its settings correctly. It turns out that the keyboard fully supports saving its settings through a power loss, and I have ben using it with these changes for the past week.</p>
<h2 id="Just-tell-me-the-steps"><a href="#Just-tell-me-the-steps" class="headerlink" title="Just tell me the steps!"></a>Just tell me the steps!</h2><p>Before we dive in, in case you just want the steps to make it work, here is how you enable persistent storage on your Drop ALT or CTRL keyboard:</p>
<h3 id="Clone-and-build-the-modified-mdloader"><a href="#Clone-and-build-the-modified-mdloader" class="headerlink" title="Clone and build the modified mdloader"></a>Clone and build the modified mdloader</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/ottobonn/mdloader</span><br><span class="line">cd mdloader</span><br><span class="line">make</span><br></pre></td></tr></table></figure>
<h3 id="Enable-Smart-EEPROM-using-mdloader"><a href="#Enable-Smart-EEPROM-using-mdloader" class="headerlink" title="Enable Smart EEPROM using mdloader"></a>Enable Smart EEPROM using mdloader</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd build</span><br><span class="line">./mdloader --first --smarteep</span><br></pre></td></tr></table></figure>
<p>While the mdloader command is waiting for a device, enter flashing mode on your keyboard with Fn + B or the tiny button on the back. After the new firmware uploads, unplug and plug in the keyboard to restart it (it will look dead, but it’s just not restarting).</p>
<h3 id="Clone-and-build-the-modified-default-keymap"><a href="#Clone-and-build-the-modified-default-keymap" class="headerlink" title="Clone and build the modified default keymap"></a>Clone and build the modified default keymap</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/ottobonn/qmk_firmware</span><br><span class="line">cd qmk_firmware</span><br><span class="line">make massdrop:ctrl/default_md</span><br></pre></td></tr></table></figure>
<p>If you have an ALT keyboard, you can adapt this keymap file for it.</p>
<h3 id="Load-the-new-firmware-on-to-the-keyboard"><a href="#Load-the-new-firmware-on-to-the-keyboard" class="headerlink" title="Load the new firmware on to the keyboard"></a>Load the new firmware on to the keyboard</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./mdloader --first --restart --download path/to/qmk_firmware/.build/massdrop_ctrl_default_md.hex</span><br></pre></td></tr></table></figure>
<p>Your keyboard should restart and should remember its settings from now on!</p>
<hr>
<h2 id="How-it-all-works"><a href="#How-it-all-works" class="headerlink" title="How it all works"></a>How it all works</h2><p>With the how-to out of the way, let’s go over how the changes work to support persistent settings on the keyboard.</p>
<h3 id="Drop-CTRL-architecture"><a href="#Drop-CTRL-architecture" class="headerlink" title="Drop CTRL architecture"></a>Drop CTRL architecture</h3><p>Let’s start with a bit of information on how the Drop CTRL and ALT are constructed. These keyboards use an ARM processor from Micron (developed by Atmel before Micron bought them) called the <a href="https://www.microchip.com/wwwproducts/en/ATSAMD51J18A">ATSAMD51</a>. This processor is popular in the newer Arduino-compatible boards like <a href="https://www.adafruit.com/product/3857">Adafruit’s Feather M4</a>. It’s super overpowered (in a good way!) for a keyboard and more than capable of its task of updating LEDs and scanning for pressed keys.</p>
<a href="/uploads/2020/10/atsamd51j18a.jpg"><img src="/uploads/2020/10/body-atsamd51j18a.jpg" alt="The actual chip inside my Drop CTRL keyboard."></a>
<p>The keyboards additionally have a USB 2.0 hub to allow one of the two onboard USB-C connectors to act as an additional port for the host computer. The keyboard processor connects to this hub as one of its downstream clients.</p>
<p>The keyboards are cool in other ways; check out my full review for all the other details.</p>
<h3 id="Persistent-storage-in-microcontrollers"><a href="#Persistent-storage-in-microcontrollers" class="headerlink" title="Persistent storage in microcontrollers"></a>Persistent storage in microcontrollers</h3><p>Microcontrollers use random-access memory to keep track of their state while they have power, just like a full-size computer does. When they lose power, they lose the contents of RAM. However, unlike a typical computer, most microcontrollers don’t have much persistent storage, like a hard drive or flash chip. Those things have to be added to the system as additional chips.</p>
<p>If you’ve programmed Arduino boards, you may already know that common microcontrollers offer a tiny bit of persistent storage in the form of EEPROM, which is like RAM that doesn’t lose its contents on power loss. Most QMK-compatible keyboards seem to be based on the Arduino-staple AVR microcontrollers, and use the AVR EEPROM to store user settings in case the keyboard loses power.</p>
<p>However, the ATSAMD51 is a much more powerful microcontroller and its designers opted to include on-board flash for nonvolatile memory instead of the more traditional EEPROM. Flash is another form of persistent memory, but it has some quirks; the main one that separates it from EEPROM is that it can only be erased in large blocks at a time, while single bytes of EEPROM are erasable.</p>
<p>To overcome the limitations of flash for more traditional EEPROM applications, the SAMD51 includes “SmartEEPROM,” a programming API that uses flash to emulate EEPROM.</p>
<p>See page 594 of <a href="http://ww1.microchip.com/downloads/en/DeviceDoc/SAM_D5xE5x_Family_Data_Sheet_DS60001507F.pdf">the datasheet</a> for the full introduction to SmartEEPROM. Here’s the overview from that page:</p>
<a href="/uploads/2020/10/smart-eeprom.png"><img src="/uploads/2020/10/body-smart-eeprom.png" alt="The introduction to SmartEEPROM from the ATSAMD51 data sheet."></a>
<p>Unfortunately, the Drop CTRL and ALT come from the factory with SmartEEPROM disabled. Fortunately, it’s easy to enable!</p>
<h3 id="Enabling-SmartEEPROM-on-the-microcontroller"><a href="#Enabling-SmartEEPROM-on-the-microcontroller" class="headerlink" title="Enabling SmartEEPROM on the microcontroller"></a>Enabling SmartEEPROM on the microcontroller</h3><p>Microcontrollers are designed to support configuration options that the software running on them can’t change, for example to protect the firmware from deletion. They store this less-voltatile configuration in “fuse bits,” so named because they emulate actual hardware wires being connected or cut during manufacture. For the most part, fuse bits retain their values when the microcontroller is reprogrammed. However, unlike hardware fuses, they are editable after manufacturing.</p>
<p>To program the fuse bits, we need to modify the application that loads new firmware onto the keyboard. For Drop keyboards, the program is “<a href="https://github.com/Massdrop/mdloader">mdloader</a>.” I didn’t write the changes we’re about to see, so I have to thank and give credit to Alexandre d’Alton for <a href="https://github.com/Massdrop/mdloader/pull/16">implementing it</a>.</p>
<p>Here’s the code that runs on the host computer to enable the SmartEEPROM fuse bits on the keyboard microcontroller:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">write_user_row</span><span class="params">(<span class="keyword">uint32_t</span> *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint16_t</span> status = read_half_word(DSU_STATUSB);</span><br><span class="line">    write_half_word(DSU_STATUSB, status);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* clear nvm interrupt status bits */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> cfg = read_word(NVMCTRL_CTRLA);</span><br><span class="line">    cfg &amp;= ~(<span class="number">0xf0</span>);</span><br><span class="line">    write_word(NVMCTRL_CTRLA, cfg);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* set user row address */</span></span><br><span class="line">    write_word(NVMCTRL_ADDR, NVMCTRL_USER);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* erase page */</span></span><br><span class="line">    write_half_word(NVMCTRL_CTRLB, (NVMCTRL_CTRLB_CMDEX_KEY|NVMCTRL_CTRLB_CMD_EP));</span><br><span class="line"></span><br><span class="line">    slp(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* erase write buffer */</span></span><br><span class="line">    write_half_word(NVMCTRL_CTRLB, (NVMCTRL_CTRLB_CMDEX_KEY|NVMCTRL_CTRLB_CMD_PBC));</span><br><span class="line"></span><br><span class="line">    slp(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* write in the write buffer */</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        write_word(NVMCTRL_USER + i * <span class="number">4</span>,  data[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* set user row address */</span></span><br><span class="line">    write_word(NVMCTRL_ADDR, NVMCTRL_USER);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* program quad word (128bits) */</span></span><br><span class="line">    write_half_word(NVMCTRL_CTRLB, (NVMCTRL_CTRLB_CMDEX_KEY|NVMCTRL_CTRLB_CMD_WQW));</span><br><span class="line"></span><br><span class="line">    slp(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Now that we have SmartEEPROM enabled, we can implement an EEPROM driver for it!</p>
<h3 id="Adding-support-for-SmartEEPROM-to-QMK"><a href="#Adding-support-for-SmartEEPROM-to-QMK" class="headerlink" title="Adding support for SmartEEPROM to QMK"></a>Adding support for SmartEEPROM to QMK</h3><p>QMK supports several different microcontrollers for keyboards, and each supported controller needs its own definitions for things like pin functions, timing, and EEPROM.</p>
<p>Let’s start by looking at the existing EEPROM code for the Drop keyboards:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;eeprom.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EEPROM_SIZE 32</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">uint8_t</span> buffer[EEPROM_SIZE];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint8_t</span> <span class="title">eeprom_read_byte</span><span class="params">(<span class="keyword">const</span> <span class="keyword">uint8_t</span> *addr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uintptr_t</span> offset = (<span class="keyword">uintptr_t</span>)addr;</span><br><span class="line">    <span class="keyword">return</span> buffer[offset];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">eeprom_write_byte</span><span class="params">(<span class="keyword">uint8_t</span> *addr, <span class="keyword">uint8_t</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uintptr_t</span> offset = (<span class="keyword">uintptr_t</span>)addr;</span><br><span class="line">    buffer[offset]   = value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This code uses an in-memory array to pretend to implement EEPROM support, so it’s not suprising that the settings get lost on power down!</p>
<p>Thankfully, the ATSAMD51 datasheet includes an example snippet for writing to SmartEEPROM:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Declare a pointer to the SmartEEPROM start address</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">uint8_t</span> *SmartEEPROM8 = (<span class="keyword">uint8_t</span> *) SEEPROM_ADDR;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Wait for the NVM to be ready</span></span><br><span class="line"><span class="keyword">while</span> (NVMCTRL-&gt;SEESTAT.bit.BUSY);</span><br><span class="line"></span><br><span class="line"><span class="comment">// now write to SEEPROM_ADDR like a normal array, e.g.:</span></span><br><span class="line">SEEPROM_ADDR[<span class="number">0</span>] = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p>Let’s build on that to implement our actual EEPROM driver:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((aligned(<span class="number">4</span>))) <span class="keyword">static</span> <span class="keyword">uint8_t</span> buffer[EEPROM_SIZE];</span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">uint8_t</span> *smart_eeprom = (<span class="keyword">uint8_t</span> *) SEEPROM_ADDR;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">smart_eeprom_enabled</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> NVMCTRL-&gt;SEESTAT.bit.PSZ &gt; <span class="number">0</span> &amp;&amp; NVMCTRL-&gt;SEESTAT.bit.SBLK &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">wait_for_eeprom_ready</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> timeout = <span class="number">10000</span>;</span><br><span class="line">    <span class="keyword">while</span> (NVMCTRL-&gt;SEESTAT.bit.BUSY &amp;&amp; timeout &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        timeout -= <span class="number">1</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> !NVMCTRL-&gt;SEESTAT.bit.BUSY;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint8_t</span> <span class="title">eeprom_read_byte</span><span class="params">(<span class="keyword">const</span> <span class="keyword">uint8_t</span> *addr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uintptr_t</span> offset = (<span class="keyword">uintptr_t</span>)addr;</span><br><span class="line">    <span class="keyword">if</span> (offset &gt;= EEPROM_SIZE) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!smart_eeprom_enabled()) &#123;</span><br><span class="line">        <span class="keyword">return</span> buffer[offset];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    wait_for_eeprom_ready();</span><br><span class="line">    <span class="keyword">return</span> smart_eeprom[offset];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">eeprom_write_byte</span><span class="params">(<span class="keyword">uint8_t</span> *addr, <span class="keyword">uint8_t</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uintptr_t</span> offset = (<span class="keyword">uintptr_t</span>)addr;</span><br><span class="line">    <span class="keyword">if</span> (offset &gt;= EEPROM_SIZE) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!smart_eeprom_enabled()) &#123;</span><br><span class="line">        buffer[offset] = value;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (wait_for_eeprom_ready()) &#123;</span><br><span class="line">        smart_eeprom[offset] = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This code preserves the existing in-memory behavior for ATSAM chips without SmartEEPROM enabled, and supports presistent storage in chips with SmartEEPROM enabled. See the full change <a href="https://github.com/ottobonn/qmk_firmware/blob/ea1ea011d82f731dda9e02675097cfa20c88e5ce/tmk_core/common/arm_atsam/eeprom.c">here</a>.</p>
<h3 id="Supporting-EEPROM-in-the-keymap"><a href="#Supporting-EEPROM-in-the-keymap" class="headerlink" title="Supporting EEPROM in the keymap"></a>Supporting EEPROM in the keymap</h3><p>Using QMK, each supported keyboard can have more than one key layout. Each layout for a keyboard gets its own <code>keymap.c</code> file to define it. The keymap additionally defines user settings, including which values the user wants to store in EEPROM.</p>
<p>To support persistent storage for settings, then, we need to modify the default CTRL keymap that Drop provides. Each time the user changes a persisted setting, like LED brightness, we will save it to EEPROM immediately in case the keyboard loses power. On startup, we will read the settings from EEPROM and restore them to their in-memory variables.</p>
<!-- TODO aside: wear optimizations -->
<p>Using the QMK EEPROM library has a catch: there are two provided settings areas, one for keyboard settings and one for user settings, and each gets four bytes of EEPROM. We will pack our settings into the four bytes of keyboard storage, leaving the user storage available for individual user tweaks.</p>
<p>We have a lot to pack into four bytes, but some of the values are small, like booleans. We can use a C union type to overlay named fields onto a 4-byte integer:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">  <span class="keyword">uint32_t</span> raw;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint8_t</span> led_animation_id: <span class="number">3</span>,</span><br><span class="line">            led_lighting_mode: <span class="number">2</span>,</span><br><span class="line">            led_animation_breathing: <span class="number">1</span>,</span><br><span class="line">            led_enabled: <span class="number">1</span>,</span><br><span class="line">            led_animation_direction: <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">uint8_t</span> gcr_desired;</span><br><span class="line">    <span class="keyword">uint8_t</span> led_animation_speed;</span><br><span class="line">    <span class="keyword">uint8_t</span> _unused;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125; <span class="keyword">kb_config_t</span>;</span><br></pre></td></tr></table></figure>
<p>Next, we need to make this data structure the source of truth for the keyboard configuration so we can persist it to EEPROM and load it on startup. I did that by writing little helper functions for each keyboard setting key press handler. Here’s an example to advance to the next LED animation:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">led_pattern_next</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    kb_config.led_animation_id = (kb_config.led_animation_id + <span class="number">1</span>) % led_setups_count;</span><br><span class="line">    sync_settings(); <span class="comment">// implemented below</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>We’ve implemented functions to store values to the new structure, so the final touch is to save and load the structure from EEPROM.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">load_saved_settings</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    kb_config.raw = eeconfig_read_kb();</span><br><span class="line"></span><br><span class="line">    led_animation_id = kb_config.led_animation_id;</span><br><span class="line">    gcr_desired = kb_config.gcr_desired;</span><br><span class="line">    led_lighting_mode = kb_config.led_lighting_mode;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> prev_led_animation_breathing = led_animation_breathing;</span><br><span class="line">    led_animation_breathing = kb_config.led_animation_breathing;</span><br><span class="line">    <span class="keyword">if</span> (led_animation_breathing &amp;&amp; !prev_led_animation_breathing) &#123;</span><br><span class="line">        gcr_breathe = gcr_desired;</span><br><span class="line">        led_animation_breathe_cur = BREATHE_MIN_STEP;</span><br><span class="line">        breathe_dir = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    led_animation_direction = kb_config.led_animation_direction;</span><br><span class="line">    led_animation_speed = kb_config.led_animation_speed;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> led_enabled = kb_config.led_enabled;</span><br><span class="line">    I2C3733_Control_Set(led_enabled);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">save_settings</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Save the keyboard config to EEPROM</span></span><br><span class="line">    eeconfig_update_kb(kb_config.raw);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sync_settings</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    save_settings();</span><br><span class="line">    load_saved_settings();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>You can find the full new keymap <a href="https://github.com/ottobonn/qmk_firmware/blob/ea1ea011d82f731dda9e02675097cfa20c88e5ce/keyboards/massdrop/ctrl/keymaps/default_md/keymap.c">here</a>.</p>
<h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h3><p>I had already decided to keep my Drop CTRL before knowing whether EEPROM storage would work, so I am really glad it is possible to support after all! I am not sure why Drop hadn’t already implemented this feature, because a lot of users have been asking about it. It makes the keyboard way better to use, particularly on a laptop where the power is intermittent.</p>
<p>Thanks for reading! Hopefully this post helps if you’re a Drop CTRL or ALT owner who needs persistent settings storage.</p>
<h3>Comments</h3><div id="cusdis_thread" data-host="https://cusdis-o3zfswldh-ottobonn.vercel.app" data-app-id="bfc86e4c-f4e1-4135-8790-cf52804a5850" data-page-id="2020/10/05/adding-persistent-settings-to-drop-ctrl/" data-page-url="https://travisgeis.com/2020/10/05/adding-persistent-settings-to-drop-ctrl/" data-page-title="Adding Persistent Settings to Drop CTRL"></div><script async src="https://cusdis-o3zfswldh-ottobonn.vercel.app/js/cusdis.es.js"></script></article><nav id="pagination"><div class="ui fluid variable item pagination menu"><a href="../../../../2021/05/25/stl-viewer/" class="item"><i class="arrow circle left icon"></i>Previous</a><a href="../../../08/30/ts100-battery/" class="item"><i class="arrow circle right icon"></i>Next</a></div></nav></div></div><div id="footer"><div class="ui stackable secondary menu"><a href="/rss2.xml" class="item"><i class="rss icon"></i>RSS</a><a href="/atom.xml" class="item"><i class="rss icon"></i>Atom</a></div></div></body></html>