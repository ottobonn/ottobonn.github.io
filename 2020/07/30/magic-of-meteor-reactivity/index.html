<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1"><title>The Magic of Meteor's Reactivity - travisgeis.com</title><link rel="stylesheet" type="text/css" href="/semantic/dist/semantic.min.css">
<script src="https://code.jquery.com/jquery-3.1.1.min.js" integrity="sha256-hVVnYaiADRTO2PzUGmuLJr8BLUSjGIZsDYGmIJLv2b8=" crossorigin="anonymous"></script>
<script src="/semantic/dist/semantic.min.js"></script><link href="https://fonts.googleapis.com/css?family=Spectral|Rubik|Anonymous+Pro" rel="stylesheet"><!-- favicon set from favicomatic.com -->
<meta name="application-name" content="travisgeis.com"/>
<link rel="apple-touch-icon-precomposed" sizes="57x57" href="/favicons/apple-touch-icon-57x57.png" />
<link rel="apple-touch-icon-precomposed" sizes="114x114" href="/favicons/apple-touch-icon-114x114.png" />
<link rel="apple-touch-icon-precomposed" sizes="72x72" href="/favicons/apple-touch-icon-72x72.png" />
<link rel="apple-touch-icon-precomposed" sizes="144x144" href="/favicons/apple-touch-icon-144x144.png" />
<link rel="apple-touch-icon-precomposed" sizes="60x60" href="/favicons/apple-touch-icon-60x60.png" />
<link rel="apple-touch-icon-precomposed" sizes="120x120" href="/favicons/apple-touch-icon-120x120.png" />
<link rel="apple-touch-icon-precomposed" sizes="76x76" href="/favicons/apple-touch-icon-76x76.png" />
<link rel="apple-touch-icon-precomposed" sizes="152x152" href="/favicons/apple-touch-icon-152x152.png" />
<link rel="icon" type="image/png" href="/favicons/favicon-196x196.png" sizes="196x196" />
<link rel="icon" type="image/png" href="/favicons/favicon-96x96.png" sizes="96x96" />
<link rel="icon" type="image/png" href="/favicons/favicon-32x32.png" sizes="32x32" />
<link rel="icon" type="image/png" href="/favicons/favicon-16x16.png" sizes="16x16" />
<link rel="icon" type="image/png" href="/favicons/favicon-128.png" sizes="128x128" />
<meta name="msapplication-TileColor" content="#FFFFFF" />
<meta name="msapplication-TileImage" content="/favicons/mstile-144x144.png" />
<meta name="msapplication-square70x70logo" content="/favicons/mstile-70x70.png" />
<meta name="msapplication-square150x150logo" content="/favicons/mstile-150x150.png" />
<meta name="msapplication-wide310x150logo" content="/favicons/mstile-310x150.png" />
<meta name="msapplication-square310x310logo" content="/favicons/mstile-310x310.png" />
<script async defer data-domain="travisgeis.com" src="https://plausible.io/js/plausible.js"></script><link rel="stylesheet" href="/css/boxy.css"><link rel="alternate" href="atom.xml" title="travisgeis.com" type="application/atom+xml">
<link rel="alternate" href="rss2.xml" title="travisgeis.com" type="application/rss+xml">
</head><body><div id="page" class="ui container"><div id="menu"><div class="ui stackable secondary variable item menu"><a href="/" class="item"><i class="icon home"></i>travisgeis.com</a><a href="/contact" class="item"><i class="icon comments"></i>Contact</a></div></div><div id="titles"><h1 class="ui huge header">The Magic of Meteor's Reactivity</h1><h3 class="ui header">30 July, 2020</h3></div><div id="content"><article id="post"><p>Reactive programming is one of the strong points of Meteor. For example, it’s what allows your Meteor app’s client views to rerender when data in Mongo collections changes.</p>
<p>Because Meteor is built with reactive capabilities, a new Meteor app gets the benefits of reactive programming right out of the box. But how does reactive programming actually work? In this article, we’ll dive behind the scenes of reactive programming in Meteor, and learn about some common points of confusion and their solutions along the way.</p>
<h2 id="Reactive-Programming-in-Meteor"><a href="#Reactive-Programming-in-Meteor" class="headerlink" title="Reactive Programming in Meteor"></a>Reactive Programming in Meteor</h2><p>Let’s take a moment to review reactive programming for those just getting started in Meteor or who haven’t used it before. Commonly throughout Meteor apps, you’ll see code like the following:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Tracker.autorun(<span class="function"><span class="keyword">function</span> <span class="title">updateTimezone</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> user = Meteor.user();</span><br><span class="line">  currentTemplate.timezone.set(user.timezone);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>In this example, we fetch the current user with <code>Meteor.user()</code>, and update the timezone of our fictional page’s template with the timezone stored on the user object. Our <code>updateTimezone</code> function is passed as the argument to <code>Tracker.autorun</code>, which will run the function immediately, and then run it again any time the return value of <code>Meteor.user</code> changes.</p>
<p>When I first encountered this reactivity, it seemed like magic. How could the autorun “know” when the return value of our call to <code>Meteor.user</code> would be different on the next call, without constantly calling the function? Furthermore, how could it possibly know which parts of our function were reading reactive data without reading our JavaScript and understanding it?</p>
<p>As usual with programming, it’s not magic, but in this case some pretty cool stuff is happening behind the scenes. Let’s take a closer look to see how it works!</p>
<h2 id="Behind-the-Scenes-Tracker-autorun"><a href="#Behind-the-Scenes-Tracker-autorun" class="headerlink" title="Behind the Scenes: Tracker.autorun"></a>Behind the Scenes: <code>Tracker.autorun</code></h2><p>Let’s dive right in and see how Meteor handles things behind the scenes, considering again our example with <code>Tracker</code>. Here’s the code again:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Tracker.autorun(<span class="function"><span class="keyword">function</span> <span class="title">updateTimezone</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> user = Meteor.user();</span><br><span class="line">  currentTemplate.timezone.set(user.timezone);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>And below, we can see the definition of Tracker.autorun. It’s quite short! (I’ve omitted a few of the argument checks for brevity):</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Tracker.autorun = <span class="function"><span class="keyword">function</span> (<span class="params">f, options</span>) </span>&#123;</span><br><span class="line">  constructingComputation = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">var</span> c = <span class="keyword">new</span> Tracker.Computation(</span><br><span class="line">    f, Tracker.currentComputation, options.onError);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (Tracker.active)</span><br><span class="line">    Tracker.onInvalidate(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      c.stop();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>When we call <code>Tracker.autorun</code>, it constructs a <code>Computation</code> object. The Meteor docs define <a href="https://docs.meteor.com/api/tracker.html#tracker_computation">Computation</a>:</p>
<blockquote>
<p>A Computation object represents code that is repeatedly rerun in response to reactive data changes.</p>
</blockquote>
<p>In this case, the code that will rerun is the function <code>setTimezone</code> that we pass to <code>Tracker.autorun</code>. Tracker passes our function (which it calls <code>f</code>) to the new computation, which stores it internally. The computation immediately calls <code>setTimezone</code>.</p>
<p>The rest of <code>Tracker.autorun</code> handles stopping the new computation if the current computation is invalidated. <!-- TODO expand on this explanation --></p>
<p>To see how the autorun reacts to changes in its inputs, we have to dig a little further, into the definition of <code>Computation</code>.</p>
<h2 id="Tracker-Computation"><a href="#Tracker-Computation" class="headerlink" title="Tracker.Computation"></a>Tracker.Computation</h2><p>Our code gets the current user information with a call to <code>Meteor.user</code>. We want our computation to rerun when anything about the user changes, so <code>Meteor.user</code> is a “dependency” of our computation.</p>
<p>The Meteor docs define a <a href="https://docs.meteor.com/api/tracker.html#tracker_dependency">Dependency</a> for us:</p>
<blockquote>
<p>A Dependency represents an atomic unit of reactive data that a computation might depend on. Reactive data sources such as Session or Minimongo internally create different Dependency objects for different pieces of data, each of which may be depended on by multiple computations. When the data changes, the computations are invalidated. […] Conceptually, the only two things a Dependency can do are gain a dependent and change.</p>
</blockquote>
<p>In our example, we’ve created one Computation, and it has one Dependency. When the Dependency changes, our Computation will rerun.</p>
<p>Now we’ve defined the core terms involved in reactive programming. But how does our computation “know” when to rerun? And how does the Dependency signal that it is a reactive data source?</p>
<h2 id="Inside-the-Dependency"><a href="#Inside-the-Dependency" class="headerlink" title="Inside the Dependency"></a>Inside the Dependency</h2><p>Using our knowledge of the relationship between Computation and Dependency, we can move to an understanding of the full reactive programming picture.</p>
<p>The Dependency class contains the secret that makes it all work. When we first call <code>Tracker.autorun</code>, Tracker constructs a new Computation and passes our code to it. Our code runs right away, which is convenient for us, but something more important is happening: during the first run of our code, we read from the reactive data sources we care about, and in doing so, we trigger a special dependency registration behind the scenes.</p>
<p>Each time we read from a reactive source, the source we’re reading calls <code>Dependency#depend</code> on its own internal dependency object and passes in the current computation, indicating that the current computation depends on this source. The internal dependency maintains a mapping of computation IDs to the corresponding Computation objects. When the reactive data source tells the dependency that the data have changed, the dependency loops through its internal collection of computations and invalidates each of them. After invalidating each computation, the dependency also removes it from the list of dependants.</p>
<h3 id="Pitfall-your-function-must-read-from-a-dependency-in-order-to-react-to-its-changes"><a href="#Pitfall-your-function-must-read-from-a-dependency-in-order-to-react-to-its-changes" class="headerlink" title="Pitfall: your function must read from a dependency in order to react to its changes"></a>Pitfall: your function must read from a dependency in order to react to its changes</h3><p>It’s important to keep in mind that from the computation’s perspective, our code is a black box. It can’t read and understand our intent like a human would!</p>
<p>To figure out what our code depends on, the computation <em>assumes</em> that we will read from every dependency we care about, every time our function runs. The computation will depend only on the dependencies it used the first time it ran. If you don’t read from a certain dependency, that dependency can’t rerun your computation.</p>
<h2 id="Tracker-currentComputation-and-the-power-of-global-variables"><a href="#Tracker-currentComputation-and-the-power-of-global-variables" class="headerlink" title="Tracker.currentComputation and the power of global variables"></a><code>Tracker.currentComputation</code> and the power of global variables</h2><p>Reactive data sources aren’t magical after all:</p>
<ol>
<li>Your function in an autorun reads from the reactive data source, which maintains an internal dependency object.</li>
<li>The data source (e.g., a Mongo lookup) passes a reference to the current computation to that dependency, and the depedency stores it.</li>
<li>The next time the reactive source has new information, like an updated Mongo document, it signals all of the dependencies’ computations that they should rerun by invalidating them.</li>
<li>Tracker reruns all of the invalidated computations on subsequent turns of the event loop</li>
</ol>
<p>The exploitable detail of this arrangement is JavaScript’s single-threaded runtime, which permits only one function to run at a time. Because the Tracker can safely assume only one function will run at once (and therefore only one Computation will run at once), it can save a reference to the <code>currentComputation</code> as a global variable! You can see the current computation for yourself in <code>Tracker.currentComputation</code>.</p>
<p>Storing the current computation in a global variable means that any reactive data source can find it trivially in order to pass it to internal Dependency objects. Whenever code in a reactive data source is running, it knows that at most one Computation could depend on the result: the global <code>currentComputation</code>.</p>
<p>It’s popular to hate on global variables these days, but the use of a global <code>currentComputation</code> is simplification at its finest. I hope this brief dip into Meteor’s reactive programming was helpful. See you next time!</p>
<script src="https://utteranc.es/client.js" repo="ottobonn/travisgeis.com" issue-term="The Magic of Meteor's Reactivity" label="comment" theme="github-light" crossorigin="anonymous" async></script></article><nav id="pagination"><div class="ui fluid variable item pagination menu"><a href="../../../08/25/handwriting-font/" class="item"><i class="arrow circle left icon"></i>Previous</a><a href="../../29/actually-working-linux-touchpad/" class="item"><i class="arrow circle right icon"></i>Next</a></div></nav></div></div><div id="footer"><div class="ui stackable secondary menu"><a href="/rss2.xml" class="item"><i class="rss icon"></i>RSS</a><a href="/atom.xml" class="item"><i class="rss icon"></i>Atom</a></div></div></body></html>