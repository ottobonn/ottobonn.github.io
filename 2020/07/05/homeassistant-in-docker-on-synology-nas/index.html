<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1"><title>Homeassistant in Docker on Synology NAS - travisgeis.com</title><link rel="stylesheet" type="text/css" href="/semantic/dist/semantic.min.css">
<script src="https://code.jquery.com/jquery-3.1.1.min.js" integrity="sha256-hVVnYaiADRTO2PzUGmuLJr8BLUSjGIZsDYGmIJLv2b8=" crossorigin="anonymous"></script>
<script src="/semantic/dist/semantic.min.js"></script><link href="https://fonts.googleapis.com/css?family=Spectral|Rubik|Anonymous+Pro" rel="stylesheet"><!-- favicon set from favicomatic.com -->
<meta name="application-name" content="travisgeis.com"/>
<link rel="apple-touch-icon-precomposed" sizes="57x57" href="/favicons/apple-touch-icon-57x57.png" />
<link rel="apple-touch-icon-precomposed" sizes="114x114" href="/favicons/apple-touch-icon-114x114.png" />
<link rel="apple-touch-icon-precomposed" sizes="72x72" href="/favicons/apple-touch-icon-72x72.png" />
<link rel="apple-touch-icon-precomposed" sizes="144x144" href="/favicons/apple-touch-icon-144x144.png" />
<link rel="apple-touch-icon-precomposed" sizes="60x60" href="/favicons/apple-touch-icon-60x60.png" />
<link rel="apple-touch-icon-precomposed" sizes="120x120" href="/favicons/apple-touch-icon-120x120.png" />
<link rel="apple-touch-icon-precomposed" sizes="76x76" href="/favicons/apple-touch-icon-76x76.png" />
<link rel="apple-touch-icon-precomposed" sizes="152x152" href="/favicons/apple-touch-icon-152x152.png" />
<link rel="icon" type="image/png" href="/favicons/favicon-196x196.png" sizes="196x196" />
<link rel="icon" type="image/png" href="/favicons/favicon-96x96.png" sizes="96x96" />
<link rel="icon" type="image/png" href="/favicons/favicon-32x32.png" sizes="32x32" />
<link rel="icon" type="image/png" href="/favicons/favicon-16x16.png" sizes="16x16" />
<link rel="icon" type="image/png" href="/favicons/favicon-128.png" sizes="128x128" />
<meta name="msapplication-TileColor" content="#FFFFFF" />
<meta name="msapplication-TileImage" content="/favicons/mstile-144x144.png" />
<meta name="msapplication-square70x70logo" content="/favicons/mstile-70x70.png" />
<meta name="msapplication-square150x150logo" content="/favicons/mstile-150x150.png" />
<meta name="msapplication-wide310x150logo" content="/favicons/mstile-310x150.png" />
<meta name="msapplication-square310x310logo" content="/favicons/mstile-310x310.png" />
<script async defer data-domain="travisgeis.com" src="https://plausible.io/js/plausible.js"></script><link rel="stylesheet" href="/css/boxy.css"><link rel="alternate" href="atom.xml" title="travisgeis.com" type="application/atom+xml">
<link rel="alternate" href="rss2.xml" title="travisgeis.com" type="application/rss+xml">
</head><body><div id="page" class="ui container"><div id="menu"><div class="ui stackable secondary variable item menu"><a href="/" class="item"><i class="icon home"></i>travisgeis.com</a><a href="/contact" class="item"><i class="icon comments"></i>Contact</a></div></div><div id="titles"><h1 class="ui huge header">Homeassistant in Docker on Synology NAS</h1><h3 class="ui header">5 July, 2020</h3></div><div id="content"><article id="post"><p>I use <a href="https://www.home-assistant.io/">homeassistant</a> to control my apartment’s lighting and some other fun things like the tea kettle. I definitely recommend it; it’s open-source and very easy to set up, and it supports many devices right away with minimal fuss. I’ll go into more detail on my home automation devices in another post. This one is about the software, and the surprising complexity of home networks.</p>
<p>Many people run homeassistant on a <a href="https://www.raspberrypi.org/">Raspberry Pi</a>, but I already had a <a href="https://www.synology.com/en-global/products/DS218+">Synology DS218+</a> NAS (network-attached storage) device that I wanted to use for home automation, too. It’s a suprisingly capable little Linux server, and since it’s always running anyway for network backups, it’s a good candidate for a home automation server.</p>
<p>In this blog post I want to explain some of the challenges of setting up a cluster of applications on the NAS and how I eventually decided to do it.</p>
<h2 id="Docker-for-personal-projects"><a href="#Docker-for-personal-projects" class="headerlink" title="Docker for personal projects"></a>Docker for personal projects</h2><p>The NAS is a computer like any other, so one option for setting up additional apps on it is to install them normally and let them control the NAS’s available ports to talk to the local network. However, installing applications one-by-one like you might on a personal computer has a few downsides:</p>
<ul>
<li>The applications might not be compatible with Synology’s specific Linux distribution, “DSM” (I’m not even sure what distro it’s based on).</li>
<li>Synology updates could inadvertently wipe out or break third-party apps I’ve installed, particularly if I need to reconfigure a preinstalled app like nginx.</li>
<li>I will <em>definitely forget</em> how I installed the apps, and when I get a new NAS I will have to start from scratch to set thigs up again.</li>
</ul>
<p>Instead of installing the apps individually, I committed to using <a href="https://www.docker.com/">Docker</a> to run each app in its own container. Docker is useful in a professional software environment for isolating applications from their host operating system and managing their dependencies, but it’s also amazing for personal projects, because it allows the developer to completely describe how an application should be configured so that the setup is reproducible later. It’s very easy to forget how a personal project works, so I really value the self-documenting nature of docker containers.</p>
<h2 id="Default-ports-on-Synology-NAS"><a href="#Default-ports-on-Synology-NAS" class="headerlink" title="Default ports on Synology NAS"></a>Default ports on Synology NAS</h2><p>Okay, there’s a catch—surely you knew there would be!</p>
<p>The Synology NAS runs its own web server, listening on ports 80 and 443 (the defaults for HTTP and HTTPS). While it is possible to free those two ports, doing so involves editing the default nginx configuration files for the NAS to move its web applications to other default ports, and those changes might not persist across OS updates. Furthermore, changes to the default ports make the NAS more annoying to use for its original purpose, and might break features that the Synology developers add later on.</p>
<p>I wanted to preserve the original functionality of the NAS, so I opted not to mess with the default ports. I assumed there must be a better way, and this blog post documents some of them.</p>
<h2 id="Running-homeassistant-in-host-networking-mode"><a href="#Running-homeassistant-in-host-networking-mode" class="headerlink" title="Running homeassistant in host networking mode"></a>Running homeassistant in host networking mode</h2><p>I started by <a href="https://www.home-assistant.io/docs/installation/docker/">running homeassistant in its own Docker container in host networking mode</a>, listening on its default port of 8123. In host networking mode, the Docker container attaches directly to the network interface of the host computer, so it behaves like the application is running on the host for the purposes of networking.</p>
<p>In this configuration, Docker provides isolation from the host operating system and keeps other ports on the container closed to traffic, and we still get the dependency management and reproducible setup of Docker containers, but we aren’t taking advantage of any virtual networking features.</p>
<p>My NAS is on the local network at <code>nas.ivy.travisgeis.com</code>, so I could see the homeassistant web interface at <code>nas.ivy.travisgeis.com:8123</code>. The NAS doesn’t use port 8123 for anything else, so it was available for homeassistant to use. Setting up this way was very quick, but I’m picky and I don’t like typing port 8123 every time I visit the homeassistant UI! I want to be able instead to use a different URL, like <code>homeassistant.example.com</code> to access the UI without specifying a port, which means the application needs to be available on the default port 80.</p>
<h2 id="nginx-as-reverse-proxy"><a href="#nginx-as-reverse-proxy" class="headerlink" title="nginx as reverse proxy"></a>nginx as reverse proxy</h2><p>With homeassistant running and the goal of making it available on its own URL, the next step is to add a reverse proxy to route traffic at this new URL to the actual port 8123. A reverse proxy intercepts traffic on the host machine and can route it to different applications based on properties of the traffic like the URL, the port, or the protocol.</p>
<p>I am familiar with <a href="http://nginx.org/">nginx</a>, a popular web server, so I decided to use it as a reverse proxy, but there are other options with the same features. Here is a diagram of nginx running as a reverse proxy on the NAS, directing traffic to our homeassistant URL to the homeassistant port, 8123:</p>
<p><img src="nginx-reverse-proxy.svg" alt=""></p>
<p>This diagram shows how other services could use additional ports on the host, but I only configured homeassistant to run this way.</p>
<p><a href="/nginx-configuration-for-reverse-proxy-to-different-ports">Here is the nginx config</a> I used to set it up.</p>
<p>This nginx configuration declares one server listening on port 80, passing all traffic to <code>http://localhost:$target_port</code>. The target port comes from the mapping declared above, based on the name of the service. For the case of homeassistant, <code>homeassistant.nas.ivy.travisgeis.com</code> will provide a <code>$name</code> of “homeassistant,” which will map to port 8123.</p>
<p>This nginx reverse proxy works well for simple services like homeassistant that run on the host’s network and need to expose one or a handful of ports. However, it doesn’t work for services that need to listen to non-http network traffic, like a DNS server. My next project was to set up <a href="https://pi-hole.net/">pihole</a>, a DNS server and ad blocker, so I was back on the hunt for a way to have multiple apps running on the NAS seamlessly.</p>
<p>One caveat for running nginx this way on the NAS: Synology provides its own default nginx configuration, and nginx runs on the NAS to host the buit-in web interfaces. In order for this copy of nginx to bind to port 80, I had to stop the already-running default instance. <a href="https://tech.setepontos.com/2018/03/25/control-synology-dsm-services-via-terminal-ssh/">Here is a good guide</a> on managing built-in services with Synology’s package system, “synopackagectl”.</p>
<h2 id="Aside-Running-nginx-in-a-container"><a href="#Aside-Running-nginx-in-a-container" class="headerlink" title="Aside: Running nginx in a container"></a>Aside: Running <a href="(http://nginx.org/">nginx</a> in a container</h2><p>Because the NAS already had a global nginx configuration for serving its own web interface, I wanted to run a separate copy of nginx in a container. Running my copy in a container keeps my configuration isolated from the global configs, and provides the usual ease of building that containers allow.</p>
<p>While I was researching running nginx in a container, I happened across <a href="https://nginxproxymanager.com/">Nginx Proxy Manager</a>. It provides a graphical interface for configuring reverse-proxy settings for different services, further reducing the risk of completely forgetting how everything works.</p>
<h2 id="Adding-pihole"><a href="#Adding-pihole" class="headerlink" title="Adding pihole"></a>Adding <a href="https://pi-hole.net/">pihole</a></h2><p>Next I wanted to set up pihole for LAN-wide ad blocking. pihole is a bit different from homeassistant, because it requires access to DNS queries, which don’t (usually) happen over HTTP.</p>
<p>Running pihole poses a few challenges:</p>
<ul>
<li>It needs access to non-HTTP ports.</li>
<li>It also wants to run a server on port 80 for its web UI.</li>
<li>It needs to have its own IP address, so the LAN router can point to it as the DNS server.</li>
</ul>
<p>Pihole expects to run on the LAN at a static IP on a dedicated host. To get it running in Docker, I needed to emulate a separate host within the Synology NAS.</p>
<h2 id="Multiple-virtual-hosts-with-Docker-macvlan"><a href="#Multiple-virtual-hosts-with-Docker-macvlan" class="headerlink" title="Multiple virtual hosts with Docker macvlan"></a>Multiple virtual hosts with Docker macvlan</h2><p>Docker has a networking driver called <a href="https://docs.docker.com/network/macvlan/">macvlan</a> that allows each container to have its own (virtualized) MAC address and IP address on the LAN. Perfect for the pihole! Thanks to <a href="http://tonylawrence.com/posts/unix/synology/free-your-synology-ports/">Tony Lawrence for his excellent guide</a> on setting up macvlan, which I adapted for this setup.</p>
<p>Using macvlan results in a pretty different network topology than using the host-mode network recommended for homeassistant. Each container on the macvlan network gets a unique IP address and MAC address on the LAN, and the macvlan network is isolated from the host. Basically you get extra virtual hosts from one computer!</p>
<p>Here are the basic steps required to transition the containers to a macvlan network:</p>
<ul>
<li>Decide on a range of IP addresses for the Docker containers</li>
<li>Create the macvlan network in Docker and allocate the reserved IP addresses to it.</li>
<li>Attach the containers to the new macvlan network.</li>
</ul>
<p>Here’s a diagram of the macvlan network topology:</p>
<p><img src="nginx-macvlan.svg" alt=""></p>
<p>Each container gets its own MAC address and IP address, and each containerized application thinks it’s on its own host computer. We know the container IP addresses won’t collide with the DHCP-assigned network addresses because we’ve allocated different ranges for them. Below, I will detail each step for this setup.</p>
<h3 id="Choose-Docker-IP-addresses"><a href="#Choose-Docker-IP-addresses" class="headerlink" title="Choose Docker IP addresses"></a>Choose Docker IP addresses</h3><p>First, decide on a subset of IP addresses to reserve for Docker. My DHCP server allocates 192.168.0.100-192.169.0.199, so I reserved 192.168.0.200-192.168.0.207 (192.168.0.200/29 in CIDR notation) for Docker containers. Each container will specify its own port in this range, so I can route to each through the nginx reverse proxy.</p>
<h3 id="Create-the-macvlan-network-in-Docker"><a href="#Create-the-macvlan-network-in-Docker" class="headerlink" title="Create the macvlan network in Docker"></a>Create the macvlan network in Docker</h3><p>I manage all the Docker containers with Docker compose, but they need to share a single macvlan network so they can communicate with each other. There is no easy way to create a shared network in Docker Compose, so I create one with the Docker CLI:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo docker network create -d macvlan \</span><br><span class="line">  --subnet=192.168.0.0/24 \</span><br><span class="line">  --gateway=192.168.0.1 \</span><br><span class="line">  --ip-range=192.168.0.200/29 \</span><br><span class="line">  --aux-address <span class="string">'host=192.168.0.101'</span> \</span><br><span class="line">  -o parent=eth0 vlan</span><br></pre></td></tr></table></figure>
<p>This command creates a macvlan network called <code>vlan</code> and allows it to allocate IP addresses 192.168.0.200-192.168.0.207. The parent interface is <code>eth0</code>, the Ethernet interface of the NAS.</p>
<h3 id="Reserve-Docker-IPs-and-route-to-them"><a href="#Reserve-Docker-IPs-and-route-to-them" class="headerlink" title="Reserve Docker IPs and route to them"></a>Reserve Docker IPs and route to them</h3><p>The containers on the macvlan network are isolated from the host by default. Add a routing rule to route the Docker subset to the macvlan network so the host can see the containers:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo ip link add macvlan link eth0 <span class="built_in">type</span> macvlan mode bridge</span><br><span class="line">sudo ip addr add 192.168.0.101/24 dev macvlan</span><br><span class="line">sudo ip link <span class="built_in">set</span> macvlan up</span><br><span class="line">sudo ip route add 192.168.0.200/29 dev macvlan</span><br></pre></td></tr></table></figure>
<p>These commands add a link network called “macvlan” to the NAS network configuration. This part was really hard to get right, because it’s right at the edge of my understanding of Linux networking. The second line attaches the new link to a range of IP addresses starting at 192.168.0.101, the third line starts it up, and the fourth line routes packets addresses to IP addresses 192.168.0.200-192.168.0.207 to the new link, which means they will end up available to the Docker containers.</p>
<h3 id="Attach-the-containers-to-the-network-in-docker-compose-files"><a href="#Attach-the-containers-to-the-network-in-docker-compose-files" class="headerlink" title="Attach the containers to the network in docker-compose files"></a>Attach the containers to the network in docker-compose files</h3><p>Finally, now that we have the “vlan” network, we need to specify that each container should attach to it. Add this “networks” config to <code>docker-compose.yml</code>:</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">networks:</span></span><br><span class="line"><span class="attr">  default:</span></span><br><span class="line"><span class="attr">    external:</span></span><br><span class="line"><span class="attr">      name:</span> <span class="string">vlan</span></span><br></pre></td></tr></table></figure>
<h2 id="GitHub-repo"><a href="#GitHub-repo" class="headerlink" title="GitHub repo"></a>GitHub repo</h2><p>Check out <a href="https://github.com/ottobonn/dsm-containers">the project on GitHub</a> for the full configuration.</p>
<script src="https://utteranc.es/client.js" repo="ottobonn/travisgeis.com" issue-term="Homeassistant in Docker on Synology NAS" label="comment" theme="github-light" crossorigin="anonymous" async></script></article><nav id="pagination"><div class="ui fluid variable item pagination menu"><a href="../../11/inside-the-apollo-kinetics-pulse/" class="item"><i class="arrow circle left icon"></i>Previous</a><a href="../../../../2019/01/13/1547425872426/" class="item"><i class="arrow circle right icon"></i>Next</a></div></nav></div></div><div id="footer"><div class="ui stackable secondary menu"><a href="/rss2.xml" class="item"><i class="rss icon"></i>RSS</a><a href="/atom.xml" class="item"><i class="rss icon"></i>Atom</a></div></div></body></html>